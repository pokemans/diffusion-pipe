<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Training Job Manager</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <h1 id="headerTitle">Training Job Manager</h1>
                <button id="createJobBtn">Create New Job</button>
            </div>
            <div id="systemStats" class="system-stats">
                <span class="stats-loading">Loading stats...</span>
            </div>
        </header>

        <div id="jobsOverview">
            <h2>Jobs Overview</h2>
            
            <div id="runningJobsSection">
                <h3>Running Jobs</h3>
                <table class="overview-table">
                    <thead>
                        <tr>
                            <th>Job Name</th>
                            <th>Status</th>
                            <th>Step</th>
                            <th>Loss</th>
                            <th>ETA</th>
                            <th>Iter Time</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="runningJobsTableBody">
                        <tr>
                            <td colspan="7" class="empty-state">Loading jobs...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div id="queuedJobsSection">
                <h3>Queued Jobs</h3>
                <table class="overview-table">
                    <thead>
                        <tr>
                            <th>Queue</th>
                            <th>Job Name</th>
                            <th>Status</th>
                            <th>Step</th>
                            <th>Loss</th>
                            <th>ETA</th>
                            <th>Iter Time</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="queuedJobsTableBody">
                        <tr>
                            <td colspan="8" class="empty-state">No jobs in queue</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div id="availableJobsSection">
                <h3>Available Jobs</h3>
                <table class="overview-table">
                    <thead>
                        <tr>
                            <th>Job Name</th>
                            <th>Status</th>
                            <th>Step</th>
                            <th>Loss</th>
                            <th>ETA</th>
                            <th>Iter Time</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="availableJobsTableBody">
                        <tr>
                            <td colspan="7" class="empty-state">No available jobs</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="jobContent" class="hidden">
            <div class="tabs">
                <button class="tab-btn" data-tab="config">Job Config</button>
                <button class="tab-btn" data-tab="dataset">Dataset Config</button>
                <button class="tab-btn" data-tab="launch">Launch Options</button>
                <button class="tab-btn active" data-tab="monitor">Monitor</button>
            </div>

            <div class="tab-content" id="configTab">
                <div class="editor-container">
                    <div class="editor-header">
                        <h3>Job Config (job_config.toml)</h3>
                        <button id="saveJobConfigBtn" class="save-btn">Save</button>
                    </div>
                    <textarea id="jobConfigEditor" class="editor"></textarea>
                </div>
            </div>

            <div class="tab-content" id="datasetTab">
                <div class="editor-container">
                    <div class="editor-header">
                        <h3>Dataset Config (dataset.toml)</h3>
                        <button id="saveDatasetConfigBtn" class="save-btn">Save</button>
                    </div>
                    <textarea id="datasetConfigEditor" class="editor"></textarea>
                </div>
            </div>

            <div class="tab-content" id="launchTab">
                <div class="launch-options-container">
                    <div class="editor-header">
                        <h3>Launch Options</h3>
                        <button id="saveLaunchOptionsBtn" class="save-btn">Save</button>
                    </div>
                    <div class="launch-form">
                        <div class="form-group">
                            <label for="envVarsInput">Environment Variables (one per line, format: KEY=VALUE):</label>
                            <textarea id="envVarsInput" class="form-textarea" rows="4" placeholder="NCCL_P2P_DISABLE=1&#10;NCCL_IB_DISABLE=1"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="deepspeedArgsInput">DeepSpeed Arguments:</label>
                            <input type="text" id="deepspeedArgsInput" class="form-input" placeholder="--num_gpus=1" value="--num_gpus=1">
                        </div>
                        <div class="form-group">
                            <label for="pythonArgsInput">Python Arguments:</label>
                            <input type="text" id="pythonArgsInput" class="form-input" placeholder="--deepspeed" value="--deepspeed">
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="useVenvInput" checked>
                                Use Virtual Environment (auto-detected)
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-content active" id="monitorTab">
                <div class="controls">
                    <button id="launchBtn" class="launch-btn">Launch Job</button>
                    <button id="stopBtn" class="stop-btn hidden">Stop Job</button>
                    <span id="jobStatus" class="status"></span>
                    <span id="jobSteps" class="status-info"></span>
                    <span id="jobETA" class="status-info"></span>
                </div>

                <div class="monitor-grid">
                    <div class="log-container">
                        <div class="log-header">
                            <h3>Logs</h3>
                            <div class="log-controls">
                                <label for="logLinesInput">Lines:</label>
                                <input type="number" id="logLinesInput" class="log-lines-input" min="1" max="10000" value="500">
                                <button id="refreshLogsBtn" class="refresh-btn">Refresh</button>
                                <button id="clearLogsBtn" class="clear-btn">Clear</button>
                            </div>
                        </div>
                        <div id="logDisplay" class="log-display"></div>
                    </div>

                    <div class="plot-container">
                        <div class="plot-header">
                            <h3>Loss vs Steps</h3>
                        </div>
                        <div class="plot-controls">
                            <div class="control-group">
                                <label>
                                    <input type="checkbox" id="movingAvgToggle">
                                    Moving Average
                                </label>
                                <div id="windowSizeGroup" class="window-size-group hidden">
                                    <label for="windowSizeSlider">Window Size:</label>
                                    <input type="range" id="windowSizeSlider" min="1" max="50" value="10">
                                    <span id="windowSizeValue">10</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="minStepInput">Min Step:</label>
                                <input type="number" id="minStepInput" min="0" placeholder="Auto">
                                <label for="maxStepInput">Max Step:</label>
                                <input type="number" id="maxStepInput" min="0" placeholder="Auto">
                                <button id="applyRangeBtn" class="small-btn">Apply Range</button>
                            </div>
                            <div class="control-group">
                                <button id="resetZoomBtn" class="small-btn">Reset Zoom</button>
                                <label id="showRawLabel" class="hidden">
                                    <input type="checkbox" id="showRawToggle">
                                    Show Raw
                                </label>
                            </div>
                        </div>
                        <canvas id="lossPlot" class="plot"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let currentJob = null;
        let lossData = {
            rawSteps: [],
            rawLosses: [],
            steps: [],
            losses: []
        };
        let plotSettings = {
            movingAverage: false,
            windowSize: 10,
            minStep: null,
            maxStep: null,
            showRaw: false
        };
        let overviewRefreshInterval = null;
        let lossChart = null;


        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadJobs();
            loadJobsOverview();
            setupEventListeners();
            startOverviewRefresh();
            initializeChart();
            startSystemStatsPolling();
        });

        function initializeChart() {
            const ctx = document.getElementById('lossPlot');
            if (!ctx) return;

            lossChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: 'Training Loss'
                        },
                        tooltip: {
                            enabled: true
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy'
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy'
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Steps'
                            },
                            type: 'linear'
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Loss'
                            }
                        }
                    }
                }
            });
        }

        function setupEventListeners() {
            // Header title click - navigate to overview
            document.getElementById('headerTitle').addEventListener('click', () => {
                hideJobContent();
                showOverview();
            });

            // Create job button
            document.getElementById('createJobBtn').addEventListener('click', () => {
                const jobName = prompt('Enter job name:');
                if (jobName && jobName.trim()) {
                    createJob(jobName.trim());
                }
            });

            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    switchTab(tab);
                });
            });

            // Save buttons
            document.getElementById('saveJobConfigBtn').addEventListener('click', () => {
                saveJobConfig();
            });

            document.getElementById('saveDatasetConfigBtn').addEventListener('click', () => {
                saveDatasetConfig();
            });

            document.getElementById('saveLaunchOptionsBtn').addEventListener('click', () => {
                saveLaunchOptions();
            });

            // Launch/Stop buttons
            document.getElementById('launchBtn').addEventListener('click', () => {
                launchJob();
            });

            document.getElementById('stopBtn').addEventListener('click', () => {
                stopJob();
            });

            // Clear logs
            document.getElementById('clearLogsBtn').addEventListener('click', () => {
                document.getElementById('logDisplay').innerHTML = '';
            });

            // Refresh logs
            document.getElementById('refreshLogsBtn').addEventListener('click', () => {
                loadJobLogs();
            });

            // Log lines input change
            document.getElementById('logLinesInput').addEventListener('change', () => {
                loadJobLogs();
            });

            // Plot controls
            document.getElementById('movingAvgToggle').addEventListener('change', (e) => {
                plotSettings.movingAverage = e.target.checked;
                const windowSizeGroup = document.getElementById('windowSizeGroup');
                const showRawLabel = document.getElementById('showRawLabel');
                if (plotSettings.movingAverage) {
                    windowSizeGroup.classList.remove('hidden');
                    showRawLabel.classList.remove('hidden');
                } else {
                    windowSizeGroup.classList.add('hidden');
                    showRawLabel.classList.add('hidden');
                    plotSettings.showRaw = false;
                    document.getElementById('showRawToggle').checked = false;
                }
                applyPlotSettings();
                updatePlot();
            });

            document.getElementById('windowSizeSlider').addEventListener('input', (e) => {
                plotSettings.windowSize = parseInt(e.target.value);
                document.getElementById('windowSizeValue').textContent = plotSettings.windowSize;
                if (plotSettings.movingAverage) {
                    applyPlotSettings();
                    updatePlot();
                }
            });

            document.getElementById('applyRangeBtn').addEventListener('click', () => {
                const minStepInput = document.getElementById('minStepInput');
                const maxStepInput = document.getElementById('maxStepInput');
                const minStep = minStepInput.value.trim() === '' ? null : parseInt(minStepInput.value);
                const maxStep = maxStepInput.value.trim() === '' ? null : parseInt(maxStepInput.value);
                
                if (minStep !== null && maxStep !== null && minStep >= maxStep) {
                    alert('Min step must be less than max step');
                    return;
                }
                
                plotSettings.minStep = minStep;
                plotSettings.maxStep = maxStep;
                applyPlotSettings();
                updatePlot();
            });

            document.getElementById('resetZoomBtn').addEventListener('click', () => {
                if (lossChart && lossChart.resetZoom) {
                    lossChart.resetZoom();
                } else if (lossChart) {
                    // Manual reset if zoom plugin not available
                    lossChart.reset();
                }
            });

            document.getElementById('showRawToggle').addEventListener('change', (e) => {
                plotSettings.showRaw = e.target.checked;
                updatePlot();
            });
        }

        async function loadJobs() {
            // Jobs are now loaded via loadJobsOverview() which shows them in tables
            // This function kept for potential future use but doesn't need to do anything
        }

        function formatETA(seconds) {
            if (!seconds || seconds < 0) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }

        function formatIterTime(seconds) {
            if (!seconds || seconds <= 0) return 'N/A';
            if (seconds < 1) {
                return `${(seconds * 1000).toFixed(0)}ms`;
            }
            return `${seconds.toFixed(2)}s`;
        }

        function renderRunningJobsTable(jobs) {
            const tbody = document.getElementById('runningJobsTableBody');
            
            if (!jobs || jobs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="empty-state">No jobs running</td></tr>';
                return;
            }
            
            tbody.innerHTML = jobs.map(job => {
                const statusClass = `status-badge ${job.status}`;
                const statusText = job.status.charAt(0).toUpperCase() + job.status.slice(1);
                const stepDisplay = job.step_display || (job.last_step !== null ? job.last_step.toString() : '-');
                // Use moving average loss for running jobs, fallback to last_loss if not available
                const lossValue = job.moving_avg_loss !== null && job.moving_avg_loss !== undefined 
                    ? job.moving_avg_loss.toFixed(4) 
                    : (job.last_loss !== null ? job.last_loss.toFixed(4) : '-');
                const eta = job.eta_seconds ? formatETA(job.eta_seconds) : 'N/A';
                const iterTime = formatIterTime(job.avg_iter_time);
                
                return `
                    <tr class="job-row" data-job="${job.job_name}">
                        <td class="job-name-cell" onclick="viewJob('${job.job_name}')">${job.job_name}</td>
                        <td><span class="${statusClass}">${statusText}</span></td>
                        <td>${stepDisplay}</td>
                        <td>${lossValue}</td>
                        <td>${eta}</td>
                        <td>${iterTime}</td>
                        <td class="action-buttons">
                            <button class="action-btn stop-btn" onclick="stopJobFromOverview('${job.job_name}')" title="Stop">
                                <span>‚èπ</span>
                            </button>
                            <button class="action-btn copy-btn" onclick="copyJob('${job.job_name}')" title="Copy Job">
                                <span>üìã</span>
                            </button>
                            <button class="action-btn view-btn" onclick="viewJob('${job.job_name}')" title="View">
                                <span>üëÅ</span>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function renderQueuedJobsTable(jobs) {
            const tbody = document.getElementById('queuedJobsTableBody');
            
            if (!jobs || jobs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="empty-state">No jobs in queue</td></tr>';
                return;
            }
            
            tbody.innerHTML = jobs.map(job => {
                const statusClass = `status-badge ${job.status}`;
                const statusText = job.status.charAt(0).toUpperCase() + job.status.slice(1);
                const stepDisplay = job.step_display || (job.last_step !== null ? job.last_step.toString() : '-');
                const lastLoss = job.last_loss !== null ? job.last_loss.toFixed(4) : '-';
                const eta = job.eta_seconds ? formatETA(job.eta_seconds) : 'N/A';
                const iterTime = formatIterTime(job.avg_iter_time);
                const queuePos = job.queue_position || '-';
                const isFirst = queuePos === 1;
                const isLast = queuePos === jobs.length;
                
                return `
                    <tr class="job-row" data-job="${job.job_name}">
                        <td class="queue-position">#${queuePos}</td>
                        <td class="job-name-cell" onclick="viewJob('${job.job_name}')">${job.job_name}</td>
                        <td><span class="${statusClass}">${statusText}</span></td>
                        <td>${stepDisplay}</td>
                        <td>${lastLoss}</td>
                        <td>${eta}</td>
                        <td>${iterTime}</td>
                        <td class="action-buttons">
                            <button class="action-btn start-btn" onclick="startJobFromQueue('${job.job_name}')" title="Start">
                                <span>‚ñ∂</span>
                            </button>
                            <button class="action-btn move-up-btn" onclick="moveJobInQueue('${job.job_name}', 'up')" title="Move Up" ${isFirst ? 'disabled' : ''}>
                                <span>‚Üë</span>
                            </button>
                            <button class="action-btn move-down-btn" onclick="moveJobInQueue('${job.job_name}', 'down')" title="Move Down" ${isLast ? 'disabled' : ''}>
                                <span>‚Üì</span>
                            </button>
                            <button class="action-btn remove-btn" onclick="removeFromQueue('${job.job_name}')" title="Remove">
                                <span>√ó</span>
                            </button>
                            <button class="action-btn copy-btn" onclick="copyJob('${job.job_name}')" title="Copy Job">
                                <span>üìã</span>
                            </button>
                            <button class="action-btn view-btn" onclick="viewJob('${job.job_name}')" title="View">
                                <span>üëÅ</span>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function renderAvailableJobsTable(jobs) {
            const tbody = document.getElementById('availableJobsTableBody');
            
            if (!jobs || jobs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="empty-state">No available jobs</td></tr>';
                return;
            }
            
            tbody.innerHTML = jobs.map(job => {
                const statusClass = `status-badge ${job.status}`;
                const statusText = job.status.charAt(0).toUpperCase() + job.status.slice(1);
                const stepDisplay = job.step_display || (job.last_step !== null ? job.last_step.toString() : '-');
                const lastLoss = job.last_loss !== null ? job.last_loss.toFixed(4) : '-';
                const eta = job.eta_seconds ? formatETA(job.eta_seconds) : 'N/A';
                const iterTime = formatIterTime(job.avg_iter_time);
                
                return `
                    <tr class="job-row" data-job="${job.job_name}">
                        <td class="job-name-cell" onclick="viewJob('${job.job_name}')">${job.job_name}</td>
                        <td><span class="${statusClass}">${statusText}</span></td>
                        <td>${stepDisplay}</td>
                        <td>${lastLoss}</td>
                        <td>${eta}</td>
                        <td>${iterTime}</td>
                        <td class="action-buttons">
                            <button class="action-btn start-btn" onclick="addJobToQueue('${job.job_name}')" title="Add to Queue">
                                <span>‚ûï</span>
                            </button>
                            <button class="action-btn copy-btn" onclick="copyJob('${job.job_name}')" title="Copy Job">
                                <span>üìã</span>
                            </button>
                            <button class="action-btn view-btn" onclick="viewJob('${job.job_name}')" title="View">
                                <span>üëÅ</span>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function viewJob(jobName) {
            loadJob(jobName);
            hideOverview();
        }

        async function loadJobsOverview() {
            try {
                const response = await fetch('/api/jobs/overview');
                const data = await response.json();
                
                renderRunningJobsTable(data.running_jobs || []);
                renderQueuedJobsTable(data.queued_jobs || []);
                renderAvailableJobsTable(data.stopped_jobs || []);
            } catch (error) {
                console.error('Error loading jobs overview:', error);
                document.getElementById('runningJobsTableBody').innerHTML = '<tr><td colspan="7" class="empty-state">Error loading overview</td></tr>';
                document.getElementById('queuedJobsTableBody').innerHTML = '<tr><td colspan="8" class="empty-state">Error loading overview</td></tr>';
                document.getElementById('availableJobsTableBody').innerHTML = '<tr><td colspan="7" class="empty-state">Error loading overview</td></tr>';
            }
        }

        function showOverview() {
            currentJob = null;  // Clear current job when showing overview
            document.getElementById('jobsOverview').classList.remove('hidden');
            loadJobsOverview();  // Load immediately
            startOverviewRefresh();
        }

        function hideOverview() {
            document.getElementById('jobsOverview').classList.add('hidden');
            stopOverviewRefresh();
        }

        function startOverviewRefresh() {
            stopOverviewRefresh();
            overviewRefreshInterval = setInterval(() => {
                if (!currentJob) {
                    loadJobsOverview();
                }
            }, 3000);
        }

        function stopOverviewRefresh() {
            if (overviewRefreshInterval) {
                clearInterval(overviewRefreshInterval);
                overviewRefreshInterval = null;
            }
        }

        async function createJob(jobName) {
            try {
                // Create empty config files
                await fetch(`/api/jobs/${jobName}/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: '# Job configuration\n' })
                });

                await fetch(`/api/jobs/${jobName}/dataset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: '# Dataset configuration\n' })
                });

                await loadJobsOverview();
                loadJob(jobName);
            } catch (error) {
                console.error('Error creating job:', error);
                alert('Error creating job: ' + error.message);
            }
        }

        async function loadJob(jobName) {
            currentJob = jobName;
            hideJobContent();
            hideOverview();

            try {
                // Load configs
                const [configRes, datasetRes] = await Promise.all([
                    fetch(`/api/jobs/${jobName}/config`),
                    fetch(`/api/jobs/${jobName}/dataset`)
                ]);

                if (configRes.ok) {
                    const configData = await configRes.json();
                    document.getElementById('jobConfigEditor').value = configData.content;
                    // Populate launch options form
                    populateLaunchOptions(configData.content);
                }

                if (datasetRes.ok) {
                    const datasetData = await datasetRes.json();
                    document.getElementById('datasetConfigEditor').value = datasetData.content;
                }

                // Load status
                await updateJobStatus();

                // Load logs
                await loadJobLogs();

                // Connect to WebSocket
                connectWebSocket(jobName);

                // Show content
                document.getElementById('jobContent').classList.remove('hidden');
            } catch (error) {
                console.error('Error loading job:', error);
                alert('Error loading job: ' + error.message);
            }
        }

        function hideJobContent() {
            document.getElementById('jobContent').classList.add('hidden');
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === `${tabName}Tab`);
            });
        }

        async function saveJobConfig() {
            if (!currentJob) return;

            const content = document.getElementById('jobConfigEditor').value;
            try {
                const response = await fetch(`/api/jobs/${currentJob}/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content })
                });

                if (response.ok) {
                    alert('Job config saved successfully');
                } else {
                    const error = await response.json();
                    alert('Error saving config: ' + error.error);
                }
            } catch (error) {
                alert('Error saving config: ' + error.message);
            }
        }

        async function saveDatasetConfig() {
            if (!currentJob) return;

            const content = document.getElementById('datasetConfigEditor').value;
            try {
                const response = await fetch(`/api/jobs/${currentJob}/dataset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content })
                });

                if (response.ok) {
                    alert('Dataset config saved successfully');
                } else {
                    const error = await response.json();
                    alert('Error saving config: ' + error.error);
                }
            } catch (error) {
                alert('Error saving config: ' + error.message);
            }
        }

        function parseLaunchConfig(configContent) {
            try {
                // Simple TOML parsing for [launch] section
                const lines = configContent.split('\n');
                let inLaunchSection = false;
                let launchLines = [];
                let bracketDepth = 0;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();
                    
                    if (trimmed === '[launch]') {
                        inLaunchSection = true;
                        continue;
                    }
                    
                    if (inLaunchSection) {
                        // Check if we've hit another section
                        if (trimmed.startsWith('[') && trimmed.endsWith(']') && trimmed !== '[launch]') {
                            break;
                        }
                        
                        // Count brackets for array parsing
                        bracketDepth += (line.match(/\[/g) || []).length;
                        bracketDepth -= (line.match(/\]/g) || []).length;
                        
                        launchLines.push(line);
                        
                        // If we've closed all brackets and we're past the first line, we might be done
                        if (bracketDepth === 0 && launchLines.length > 1 && trimmed && !trimmed.includes('=')) {
                            // Might be done, but check if next line is empty or starts a new section
                            if (i + 1 < lines.length) {
                                const nextTrimmed = lines[i + 1].trim();
                                if (nextTrimmed === '' || (nextTrimmed.startsWith('[') && nextTrimmed.endsWith(']'))) {
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (launchLines.length === 0) {
                    return null;
                }
                
                // Parse the launch section
                const launchSection = launchLines.join('\n');
                const config = {};
                
                // Parse env_vars array - handle multi-line arrays
                const envVarsMatch = launchSection.match(/env_vars\s*=\s*\[([\s\S]*?)\]/);
                if (envVarsMatch) {
                    const envVarsContent = envVarsMatch[1];
                    // Split by comma, but handle quoted strings that might contain commas
                    const envVars = [];
                    let current = '';
                    let inQuotes = false;
                    let quoteChar = null;
                    
                    for (let char of envVarsContent) {
                        if ((char === '"' || char === "'") && !inQuotes) {
                            inQuotes = true;
                            quoteChar = char;
                        } else if (char === quoteChar && inQuotes) {
                            inQuotes = false;
                            quoteChar = null;
                        } else if (char === ',' && !inQuotes) {
                            const trimmed = current.trim().replace(/^["']|["']$/g, '');
                            if (trimmed) envVars.push(trimmed);
                            current = '';
                            continue;
                        }
                        current += char;
                    }
                    if (current.trim()) {
                        const trimmed = current.trim().replace(/^["']|["']$/g, '');
                        if (trimmed) envVars.push(trimmed);
                    }
                    
                    if (envVars.length > 0) {
                        config.env_vars = envVars;
                    }
                }
                
                // Parse deepspeed_args - handle both quoted and unquoted
                const deepspeedMatch = launchSection.match(/deepspeed_args\s*=\s*(?:["']([^"']+)["']|([^\n]+))/);
                if (deepspeedMatch) {
                    config.deepspeed_args = (deepspeedMatch[1] || deepspeedMatch[2]).trim();
                }
                
                // Parse python_args - handle both quoted and unquoted
                const pythonMatch = launchSection.match(/python_args\s*=\s*(?:["']([^"']+)["']|([^\n]+))/);
                if (pythonMatch) {
                    config.python_args = (pythonMatch[1] || pythonMatch[2]).trim();
                }
                
                // Parse use_venv
                const venvMatch = launchSection.match(/use_venv\s*=\s*(true|false)/i);
                if (venvMatch) {
                    config.use_venv = venvMatch[1].toLowerCase() === 'true';
                }
                
                return Object.keys(config).length > 0 ? config : null;
            } catch (error) {
                console.error('Error parsing launch config:', error);
                return null;
            }
        }

        function populateLaunchOptions(configContent) {
            const launchConfig = parseLaunchConfig(configContent);
            
            if (launchConfig) {
                // Populate environment variables
                if (launchConfig.env_vars && Array.isArray(launchConfig.env_vars)) {
                    document.getElementById('envVarsInput').value = launchConfig.env_vars.join('\n');
                } else {
                    document.getElementById('envVarsInput').value = 'NCCL_P2P_DISABLE=1\nNCCL_IB_DISABLE=1';
                }
                
                // Populate deepspeed args
                if (launchConfig.deepspeed_args) {
                    document.getElementById('deepspeedArgsInput').value = launchConfig.deepspeed_args;
                } else {
                    document.getElementById('deepspeedArgsInput').value = '--num_gpus=1';
                }
                
                // Populate python args
                if (launchConfig.python_args) {
                    document.getElementById('pythonArgsInput').value = launchConfig.python_args;
                } else {
                    document.getElementById('pythonArgsInput').value = '--deepspeed';
                }
                
                // Populate use_venv checkbox
                if (launchConfig.use_venv !== undefined) {
                    document.getElementById('useVenvInput').checked = launchConfig.use_venv;
                } else {
                    document.getElementById('useVenvInput').checked = true;
                }
            } else {
                // Use defaults
                document.getElementById('envVarsInput').value = 'NCCL_P2P_DISABLE=1\nNCCL_IB_DISABLE=1';
                document.getElementById('deepspeedArgsInput').value = '--num_gpus=1';
                document.getElementById('pythonArgsInput').value = '--deepspeed';
                document.getElementById('useVenvInput').checked = true;
            }
        }

        function updateLaunchSectionInToml(tomlContent, launchConfig) {
            // Check if [launch] section exists
            const launchSectionRegex = /\[launch\][\s\S]*?(?=\n\[|\n*$)/;
            const hasLaunchSection = launchSectionRegex.test(tomlContent);
            
            // Build launch section TOML
            const envVarsArray = launchConfig.env_vars
                .filter(v => v.trim())
                .map(v => {
                    const trimmed = v.trim();
                    // Escape quotes if present
                    if (trimmed.includes('"')) {
                        return `'${trimmed}'`;
                    }
                    return `"${trimmed}"`;
                })
                .join(', ');
            
            // Escape quotes in strings
            const escapeQuotes = (str) => str.replace(/"/g, '\\"');
            
            const launchSection = `[launch]
env_vars = [${envVarsArray}]
deepspeed_args = "${escapeQuotes(launchConfig.deepspeed_args)}"
python_args = "${escapeQuotes(launchConfig.python_args)}"
use_venv = ${launchConfig.use_venv}
`;
            
            if (hasLaunchSection) {
                // Replace existing section
                return tomlContent.replace(launchSectionRegex, launchSection.trim());
            } else {
                // Append at the end
                return tomlContent.trim() + '\n\n' + launchSection;
            }
        }

        async function saveLaunchOptions() {
            if (!currentJob) return;

            // Get form values
            const envVarsText = document.getElementById('envVarsInput').value;
            const envVars = envVarsText
                .split('\n')
                .map(v => v.trim())
                .filter(v => v && v.includes('='));
            
            const deepspeedArgs = document.getElementById('deepspeedArgsInput').value.trim();
            const pythonArgs = document.getElementById('pythonArgsInput').value.trim();
            const useVenv = document.getElementById('useVenvInput').checked;
            
            // Validate
            if (!deepspeedArgs) {
                alert('DeepSpeed arguments cannot be empty');
                return;
            }
            
            if (!pythonArgs) {
                alert('Python arguments cannot be empty');
                return;
            }
            
            try {
                // Get current config
                const configResponse = await fetch(`/api/jobs/${currentJob}/config`);
                if (!configResponse.ok) {
                    throw new Error('Failed to load current config');
                }
                
                const configData = await configResponse.json();
                const currentConfig = configData.content;
                
                // Update launch section
                const launchConfig = {
                    env_vars: envVars.length > 0 ? envVars : ['NCCL_P2P_DISABLE=1', 'NCCL_IB_DISABLE=1'],
                    deepspeed_args: deepspeedArgs,
                    python_args: pythonArgs,
                    use_venv: useVenv
                };
                
                const updatedConfig = updateLaunchSectionInToml(currentConfig, launchConfig);
                
                // Save updated config
                const saveResponse = await fetch(`/api/jobs/${currentJob}/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: updatedConfig })
                });

                if (saveResponse.ok) {
                    alert('Launch options saved successfully');
                    // Reload config editor to show updated content
                    const reloadResponse = await fetch(`/api/jobs/${currentJob}/config`);
                    if (reloadResponse.ok) {
                        const reloadData = await reloadResponse.json();
                        document.getElementById('jobConfigEditor').value = reloadData.content;
                    }
                } else {
                    const error = await saveResponse.json();
                    alert('Error saving launch options: ' + error.error);
                }
            } catch (error) {
                alert('Error saving launch options: ' + error.message);
            }
        }

        async function launchJob() {
            if (!currentJob) return;

            try {
                const response = await fetch(`/api/jobs/${currentJob}/launch`, {
                    method: 'POST'
                });

                if (response.ok) {
                    // Clear previous logs and plot
                    document.getElementById('logDisplay').innerHTML = '';
                    lossData = {
                        rawSteps: [],
                        rawLosses: [],
                        steps: [],
                        losses: []
                    };
                    plotSettings.minStep = null;
                    plotSettings.maxStep = null;
                    document.getElementById('minStepInput').value = '';
                    document.getElementById('maxStepInput').value = '';
                    applyPlotSettings();
                    updatePlot();

                    // Update UI
                    document.getElementById('launchBtn').classList.add('hidden');
                    document.getElementById('stopBtn').classList.remove('hidden');
                    document.getElementById('jobStatus').textContent = 'Status: Running';
                    document.getElementById('jobStatus').className = 'status running';

                    // Switch to monitor tab
                    switchTab('monitor');
                } else {
                    const error = await response.json();
                    alert('Error launching job: ' + error.error);
                }
            } catch (error) {
                alert('Error launching job: ' + error.message);
            }
        }

        async function stopJob() {
            if (!currentJob) return;

            try {
                const response = await fetch(`/api/jobs/${currentJob}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    document.getElementById('launchBtn').classList.remove('hidden');
                    document.getElementById('stopBtn').classList.add('hidden');
                    document.getElementById('jobStatus').textContent = 'Status: Stopped';
                    document.getElementById('jobStatus').className = 'status stopped';
                } else {
                    const error = await response.json();
                    alert('Error stopping job: ' + error.error);
                }
            } catch (error) {
                alert('Error stopping job: ' + error.message);
            }
        }

        async function stopJobFromOverview(jobName) {
            try {
                const response = await fetch(`/api/jobs/${jobName}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    loadJobsOverview();
                } else {
                    const error = await response.json();
                    alert('Error stopping job: ' + error.error);
                }
            } catch (error) {
                alert('Error stopping job: ' + error.message);
            }
        }

        async function startJobFromQueue(jobName) {
            try {
                const response = await fetch(`/api/jobs/${jobName}/queue/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    loadJobsOverview();
                } else {
                    const error = await response.json();
                    alert('Error starting job: ' + error.error);
                }
            } catch (error) {
                alert('Error starting job: ' + error.message);
            }
        }

        async function moveJobInQueue(jobName, direction) {
            try {
                const endpoint = direction === 'up' ? 'move_up' : 'move_down';
                const response = await fetch(`/api/jobs/${jobName}/queue/${endpoint}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    loadJobsOverview();
                } else {
                    const error = await response.json();
                    alert('Error moving job: ' + error.error);
                }
            } catch (error) {
                alert('Error moving job: ' + error.message);
            }
        }

        async function removeFromQueue(jobName) {
            if (!confirm(`Remove ${jobName} from queue?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/jobs/${jobName}/queue/remove`, {
                    method: 'POST'
                });

                if (response.ok) {
                    loadJobsOverview();
                } else {
                    const error = await response.json();
                    alert('Error removing job: ' + error.error);
                }
            } catch (error) {
                alert('Error removing job: ' + error.message);
            }
        }

        async function addJobToQueue(jobName) {
            try {
                const response = await fetch(`/api/jobs/${jobName}/queue/add`, {
                    method: 'POST'
                });

                if (response.ok) {
                    loadJobsOverview();
                } else {
                    const error = await response.json();
                    alert('Error adding job to queue: ' + error.error);
                }
            } catch (error) {
                alert('Error adding job to queue: ' + error.message);
            }
        }

        async function copyJob(jobName) {
            const newJobName = prompt(`Enter new job name for copying '${jobName}':`);
            
            if (!newJobName || !newJobName.trim()) {
                return; // User cancelled or entered empty string
            }
            
            const trimmedName = newJobName.trim();
            
            // Basic validation
            if (trimmedName.includes('..') || trimmedName.includes('/') || trimmedName.includes('\\')) {
                alert('Job name cannot contain path separators');
                return;
            }
            
            try {
                const response = await fetch(`/api/jobs/${jobName}/copy`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ new_job_name: trimmedName })
                });

                if (response.ok) {
                    const result = await response.json();
                    alert(`Job copied successfully to '${trimmedName}'`);
                    loadJobsOverview();
                } else {
                    const error = await response.json();
                    alert('Error copying job: ' + error.error);
                }
            } catch (error) {
                alert('Error copying job: ' + error.message);
            }
        }

        async function updateJobStatus() {
            if (!currentJob) return;

            try {
                const response = await fetch(`/api/jobs/${currentJob}/status`);
                const status = await response.json();

                if (status.running) {
                    document.getElementById('launchBtn').classList.add('hidden');
                    document.getElementById('stopBtn').classList.remove('hidden');
                    document.getElementById('jobStatus').textContent = 'Status: Running';
                    document.getElementById('jobStatus').className = 'status running';
                } else {
                    document.getElementById('launchBtn').classList.remove('hidden');
                    document.getElementById('stopBtn').classList.add('hidden');
                    document.getElementById('jobStatus').textContent = 'Status: Stopped';
                    document.getElementById('jobStatus').className = 'status stopped';
                }
                
                // Update steps display
                const stepsElement = document.getElementById('jobSteps');
                const etaElement = document.getElementById('jobETA');
                if (status.statistics && status.statistics.length > 0) {
                    const lastStat = status.statistics[status.statistics.length - 1];
                    const currentStep = lastStat.step;
                    const totalSteps = lastStat.total_steps || status.total_steps;
                    if (totalSteps) {
                        stepsElement.textContent = `Steps: ${currentStep}/${totalSteps}`;
                    } else {
                        stepsElement.textContent = `Steps: ${currentStep}/?`;
                    }
                    
                    // Update ETA
                    if (lastStat.eta_seconds) {
                        etaElement.textContent = `ETA: ${formatETA(lastStat.eta_seconds)}`;
                    } else {
                        etaElement.textContent = 'ETA: N/A';
                    }
                } else {
                    stepsElement.textContent = '';
                    etaElement.textContent = '';
                }

                // Update plot with existing statistics
                if (status.statistics && status.statistics.length > 0) {
                    // Merge statistics instead of overwriting - preserve WebSocket-accumulated data
                    const existingSteps = new Set(lossData.rawSteps);
                    const newStats = status.statistics.filter(s => !existingSteps.has(s.step));
                    
                    // Append new statistics that aren't already present
                    newStats.forEach(stat => {
                        lossData.rawSteps.push(stat.step);
                        lossData.rawLosses.push(stat.loss);
                    });
                    
                    // If we have no existing data, use all statistics from API
                    if (lossData.rawSteps.length === 0) {
                        lossData.rawSteps = status.statistics.map(s => s.step);
                        lossData.rawLosses = status.statistics.map(s => s.loss);
                    }
                    
                    applyPlotSettings();
                    updatePlot();
                } else {
                    // Don't overwrite existing data if statistics are empty - only update plot if we have existing data
                    // This prevents clearing the plot when server returns empty statistics (e.g., after page refresh)
                    if (lossData.rawSteps.length > 0) {
                        applyPlotSettings();
                        updatePlot();
                    }
                    // If no existing data and no statistics, don't call updatePlot() - this prevents clearing an empty plot
                }
            } catch (error) {
                console.error('Error updating status:', error);
            }
        }

        async function loadJobLogs() {
            if (!currentJob) return;

            const numLines = parseInt(document.getElementById('logLinesInput').value) || 500;
            
            try {
                const response = await fetch(`/api/jobs/${currentJob}/logs?lines=${numLines}`);
                if (response.ok) {
                    const data = await response.json();
                    const logDisplay = document.getElementById('logDisplay');
                    logDisplay.innerHTML = '';
                    
                    data.logs.forEach(line => {
                        const lineElement = document.createElement('div');
                        lineElement.className = 'log-line';
                        lineElement.textContent = line;
                        logDisplay.appendChild(lineElement);
                    });
                    
                    // Scroll to bottom
                    logDisplay.scrollTop = logDisplay.scrollHeight;
                }
            } catch (error) {
                console.error('Error loading logs:', error);
            }
        }

        function connectWebSocket(jobName) {
            if (socket) {
                socket.disconnect();
            }

            socket = io();
            
            socket.on('connect', () => {
                socket.emit('subscribe_logs', { job_name: jobName });
            });

            socket.on('log_line', (data) => {
                const logDisplay = document.getElementById('logDisplay');
                const numLines = parseInt(document.getElementById('logLinesInput').value) || 500;
                
                // Add new line
                const line = document.createElement('div');
                line.className = 'log-line';
                line.textContent = data.line;
                logDisplay.appendChild(line);
                
                // Keep only the most recent N lines
                const lines = logDisplay.querySelectorAll('.log-line');
                if (lines.length > numLines) {
                    const linesToRemove = lines.length - numLines;
                    for (let i = 0; i < linesToRemove; i++) {
                        lines[i].remove();
                    }
                }
                
                logDisplay.scrollTop = logDisplay.scrollHeight;
            });

            socket.on('statistics', (data) => {
                const stats = data.stats;
                lossData.rawSteps.push(stats.step);
                lossData.rawLosses.push(stats.loss);
                
                // Update steps and ETA display
                const stepsElement = document.getElementById('jobSteps');
                const etaElement = document.getElementById('jobETA');
                if (stats.total_steps) {
                    stepsElement.textContent = `Steps: ${stats.step}/${stats.total_steps}`;
                } else {
                    stepsElement.textContent = `Steps: ${stats.step}/?`;
                }
                if (stats.eta_seconds) {
                    etaElement.textContent = `ETA: ${formatETA(stats.eta_seconds)}`;
                } else {
                    etaElement.textContent = 'ETA: N/A';
                }
                
                applyPlotSettings();
                updatePlot();
            });

            socket.on('job_finished', () => {
                document.getElementById('launchBtn').classList.remove('hidden');
                document.getElementById('stopBtn').classList.add('hidden');
                document.getElementById('jobStatus').textContent = 'Status: Finished';
                document.getElementById('jobStatus').className = 'status finished';
            });

            socket.on('job_stopped', () => {
                document.getElementById('launchBtn').classList.remove('hidden');
                document.getElementById('stopBtn').classList.add('hidden');
                document.getElementById('jobStatus').textContent = 'Status: Stopped';
                document.getElementById('jobStatus').className = 'status stopped';
            });
        }

        function calculateMovingAverage(values, windowSize) {
            if (values.length === 0) return [];
            if (windowSize <= 1) return values;
            
            const smoothed = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < values.length; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(values.length, i + halfWindow + 1);
                const window = values.slice(start, end);
                const avg = window.reduce((a, b) => a + b, 0) / window.length;
                smoothed.push(avg);
            }
            
            return smoothed;
        }

        function applyStepRange(steps, losses, minStep, maxStep) {
            if (steps.length === 0) return { steps: [], losses: [] };
            
            let filteredSteps = steps;
            let filteredLosses = losses;
            
            if (minStep !== null && minStep !== '') {
                const minIdx = steps.findIndex(s => s >= minStep);
                if (minIdx >= 0) {
                    filteredSteps = filteredSteps.slice(minIdx);
                    filteredLosses = filteredLosses.slice(minIdx);
                } else {
                    // All steps are below minStep
                    return { steps: [], losses: [] };
                }
            }
            
            if (maxStep !== null && maxStep !== '') {
                const maxIdx = filteredSteps.findIndex(s => s > maxStep);
                if (maxIdx >= 0) {
                    filteredSteps = filteredSteps.slice(0, maxIdx);
                    filteredLosses = filteredLosses.slice(0, maxIdx);
                }
            }
            
            return { steps: filteredSteps, losses: filteredLosses };
        }

        function applyPlotSettings() {
            // Start with raw data
            let steps = [...lossData.rawSteps];
            let losses = [...lossData.rawLosses];
            
            // Apply step range filter
            if (plotSettings.minStep !== null || plotSettings.maxStep !== null) {
                const filtered = applyStepRange(steps, losses, plotSettings.minStep, plotSettings.maxStep);
                steps = filtered.steps;
                losses = filtered.losses;
            }
            
            // Apply moving average if enabled
            if (plotSettings.movingAverage && losses.length > 0) {
                losses = calculateMovingAverage(losses, plotSettings.windowSize);
            }
            
            // Update the display arrays
            lossData.steps = steps;
            lossData.losses = losses;
        }

        function updatePlot() {
            if (!lossChart) {
                return;
            }

            // Early return if no data at all - prevents clearing plot unnecessarily
            if (lossData.rawSteps.length === 0 && lossData.steps.length === 0) {
                return;
            }

            const datasets = [];
            
            // Add smoothed/filtered dataset
            if (lossData.steps.length > 0) {
                const dataPoints = lossData.steps.map((step, idx) => ({
                    x: step,
                    y: lossData.losses[idx]
                }));
                
                datasets.push({
                    label: plotSettings.movingAverage ? 'Smoothed Loss' : 'Loss',
                    data: dataPoints,
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    fill: false,
                    tension: 0.1
                });
            }
            
            // Add raw dataset if enabled and moving average is on
            if (plotSettings.showRaw && plotSettings.movingAverage && lossData.rawSteps.length > 0) {
                let rawSteps = [...lossData.rawSteps];
                let rawLosses = [...lossData.rawLosses];
                
                // Apply step range to raw data too
                if (plotSettings.minStep !== null || plotSettings.maxStep !== null) {
                    const filtered = applyStepRange(rawSteps, rawLosses, plotSettings.minStep, plotSettings.maxStep);
                    rawSteps = filtered.steps;
                    rawLosses = filtered.losses;
                }
                
                if (rawSteps.length > 0) {
                    const rawDataPoints = rawSteps.map((step, idx) => ({
                        x: step,
                        y: rawLosses[idx]
                    }));
                    
                    datasets.push({
                        label: 'Raw Loss',
                        data: rawDataPoints,
                        borderColor: '#cccccc',
                        backgroundColor: 'rgba(204, 204, 204, 0.1)',
                        borderWidth: 1,
                        pointRadius: 1,
                        pointHoverRadius: 3,
                        fill: false,
                        tension: 0.1,
                        pointBackgroundColor: 'rgba(204, 204, 204, 0.5)',
                        pointBorderColor: 'rgba(204, 204, 204, 0.5)'
                    });
                }
            }

            // Don't update plot if there are no datasets - this prevents clearing an existing plot
            if (datasets.length === 0) {
                return;
            }

            // Update chart data
            lossChart.data.datasets = datasets;
            
            // Update legend visibility
            lossChart.options.plugins.legend.display = datasets.length > 1;
            
            // Update chart
            lossChart.update('none'); // 'none' mode for better performance with real-time updates
        }

        // Poll for status updates
        setInterval(() => {
            if (currentJob) {
                updateJobStatus();
            }
        }, 2000);

        // System Statistics
        let systemStatsInterval = null;

        function formatGB(bytes) {
            return (bytes / (1024 ** 3)).toFixed(1);
        }

        function renderSystemStats(data) {
            const container = document.getElementById('systemStats');
            if (!container) return;

            const parts = [];

            // CPU Stats
            if (data.cpu && Object.keys(data.cpu).length > 0) {
                const cpu = data.cpu;
                parts.push(`‚öôÔ∏è CPU: ${cpu.percent}%`);
            }

            // GPU Stats
            if (data.gpu && data.gpu.available) {
                const gpu = data.gpu;
                parts.push(`üñ•Ô∏è ${gpu.utilization}%`);
                parts.push(`üíæ ${gpu.memory_used_gb}/${gpu.memory_total_gb} GB`);
                parts.push(`üå°Ô∏è ${gpu.temperature}¬∞C`);
            }

            // Memory Stats
            if (data.memory && Object.keys(data.memory).length > 0) {
                const mem = data.memory;
                parts.push(`üß† ${mem.used_gb}/${mem.total_gb} GB`);
            }

            // Swap Stats
            if (data.swap && Object.keys(data.swap).length > 0 && data.swap.total_gb > 0) {
                const swap = data.swap;
                parts.push(`üíø ${swap.used_gb}/${swap.total_gb} GB`);
            }

            if (parts.length === 0) {
                container.innerHTML = '<span class="stats-unavailable">Stats unavailable</span>';
            } else {
                container.innerHTML = parts.join(' | ');
            }
        }

        async function loadSystemStats() {
            try {
                const response = await fetch('/api/system/stats');
                if (response.ok) {
                    const data = await response.json();
                    renderSystemStats(data);
                } else {
                    document.getElementById('systemStats').innerHTML = '<span class="stats-unavailable">Stats unavailable</span>';
                }
            } catch (error) {
                console.error('Error loading system stats:', error);
                document.getElementById('systemStats').innerHTML = '<span class="stats-unavailable">Stats unavailable</span>';
            }
        }

        function startSystemStatsPolling() {
            // Load immediately
            loadSystemStats();
            // Then poll every 2 seconds
            systemStatsInterval = setInterval(loadSystemStats, 2000);
        }

        function stopSystemStatsPolling() {
            if (systemStatsInterval) {
                clearInterval(systemStatsInterval);
                systemStatsInterval = null;
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            stopSystemStatsPolling();
        });
    </script>
</body>
</html>
